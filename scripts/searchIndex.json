{
"search":[
{
"title":"Home - STAMINA Model Checker"
, "date":"Thu Aug 4 11:22:10 2022"
, "url":"https://staminachecker.org/index.html"
, "content":" STAMINA: STochastic Approximate Model-checker for INfinite-state Analysis STAMINA can analyze unbounded and infinite-sized models, as well as models with very large state spaces, and provide an accurate bound of probabilities for CSL properties. It has been tested on genetic circuit and biological models, and has been the subject of multiple papers. Learn More Acknowledgements The development of STAMINA (and all FLUENT projects) is generously funded by grants 1856733, 1856740, and 1900542 from the National Science Foundation. Any opinions, findings, and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the National Science Foundation. STAMINA is developed at the Utah State University College of Engineering, in the Electrical and Computer Engineering Department. "
}
, {
"title":"Get Source Code - STAMINA Model Checker"
, "date":"Thu Jul 28 14:24:14 2022"
, "url":"https://staminachecker.org/source.html"
, "content":" Which version of STAMINA do you want? STAMINA/STORM STAMINA/PRISM Please note that both of these links are external. They will take you to our GitHub pages. To get STAMINA/STORM, please clone the following GitHub URL: git clone https://github.com/fluentverification/stamina-storm stamina-storm To get STAMINA/PRISM, please clone the following GitHub URL: git clone https://github.com/fluentverification/stamina-prism stamina-prism STAMINA/STORM is the newest version of STAMINA, integrating with the STORM model checker. It supports the STAMINA 2.0, 2.5, and will soon support 3.0 and multithreading. STAMINA/PRISM is the legacy version of STAMINA, integrating with the PRISM model checker. It is written in Java and supports the STAMINA 1.0 and 2.0 algorithms. Go Back Go to Homepage "
}
, {
"title":"Privacy - STAMINA Model Checker"
, "date":"Thu Aug 4 11:23:18 2022"
, "url":"https://staminachecker.org/privacy.html"
, "content":" Privacy Policy We don't store any data about you, track you, or include any cross-site trackers. We do include fonts from the Google font API and use Kwes as our form backend on the about page, and although we tried to choose these services such that they will respect your privacy as well, we can't guarantee that they aren't tracking you either. Additionally, this website is hosted on GitHub Pages, which has a privacy policy that can be accessed here. Again, since this is a third-party service, we cannot guarantee that they aren't tracking you. Because we care about your online privacy, we'd like to include some tips for online privacy that you can use. Tips for Online Privacy The following are Josh's tips for online privacy: Use an open-source privacy respecting web browser, such as Firefox, Librewolf (an open source fork of Firefox without the telemetry!), or Ungoogled Chromium. Even a browser such as Midori or Falkon that are included with smaller Linux distributions are more private than mainstream browsers like Chrome or Edge. Configure your browser to erase cookies and cache data periodically. (I do it on browser exit). Install uBlock Origin. Seriously. This thing is S-tier. I personally use it to disable scripting on all sites except for sites which I whitelist. Check your browser's fingerprint on EFF's Cover Your Tracks website. EFF is an interest group that fights for online privacy. Your browser will probably have a unique fingerprint, but virtually all modern browsers do. To see what types of cookies a website is storing about you, open up your JavaScript console, and enter document.cookie into the console. The cookie element is a string that is space-delimited and contains values in the format name=value. For this site, your cookie will look something like this: \"color-scheme=dark expires=Fri, 16 Jun 2023 23:02:44 GMT\" "
}
, {
"title":"About - STAMINA Model Checker"
, "date":"Mon Aug 8 16:01:06 2022"
, "url":"https://staminachecker.org/about.html"
, "content":" Contents Mission and Maintainers Introduction to STAMINA Frequently Asked Questions The STAMINA Algorithm Contact About STAMINA STAMINA is designed to work with large or infinite state space models and truncate them so that the probability of a CSL path property holding given an initial state is bounded within a window. It is developed within Dr. Zhen Zhang's research group at Utah State University and maintained by the following people: Current Maintainer: Josh Jeppson, B.Sc. PhD Student - Utah State University Email: [Click To See Email] Past Maintainers and Code Contributors: Riley Roberts* Andrew Williams Bret Jepsen Thakur Neupane** Lukas Buecherl† * Made significant contribution to the STAMINA Algorithm ** Initial STAMINA developer † Contributed unbounded models for testing (particularly Hazard Circuit models) Introduction to STAMINA STAMINA is an infinite state-space model truncation tool compatible with both PRISM and STORM. STAMINA is a tool within the FLUENT toolchain. It deploys a state truncation-based approach, estimating path probabilities of reaching each state on-the-fly and terminates exploration of a path when the cumulative estimated probability along such a path drops below a predefined threshold. Each terminated path is routed to an absorbing state, in order to estimate the error probability in subsequent CTMC analysis. After all paths have been explored or truncated, transient Markov chain analysis is applied to determine the probability of a transient property of interest specified using Continuous Stochastic Logic (CSL). The calculated probability forms a lower bound on the probability, while the upper bound also includes the probability of the absorbing state. The actual probability of the CSL property is guaranteed to be within this range. If the probability bound is still too large compared to a user-provided probability precision value (default is 10-3), the PRISM version of STAMINA employs a property property-guided refinement technique to expand the state space to tighten the reported probability range incrementally. Frequently Asked Questions What model checking engines does STAMINA support? STAMINA supports the STORM and PRISM model checking engines, and it supports models written in the PRISM language. Future work includes making STAMINA compatible with JANI and other model formats. What types of models does STAMINA support? Currently, STAMINA/PRISM supports only CTMCs, whereas STAMINA/STORM supports both CTMCs, and has alpha support for DTMCs through the STORM API. Why would we want to check an infinite (or very large) model? STAMINA was developed primarily to check models representative of chemical reaction networks in synthetic biology. Because each combination of molecules is a state, even a bounded reaction network could have an infinite or extremely large number of states, making the resulting model non-trivial for a traditional model checker such as STORM or PRISM. In order to actually extract useful information from these models, and to test them against CSL properties, STAMINA was developed. The STAMINA Algorithm(s) STAMINA makes use of multiple variations on a smart breadth-first search algorithm to estimate reachability probability on-the-fly. It does not explore paths whose reachability is below a certain user-defined threshold, κ, which automatically decrements until the probability window is within a certain bound. Currently there are several variations on the STAMINA algorithm. To learn more about the STAMINA algorithms, please visit the wiki page. Contact the Developers of STAMINA Full Name: Organization: Email: Position: Organization Type: Academic Research Industry Subject "
}
, {
"title":"Get - STAMINA Model Checker"
, "date":"Thu Aug 4 11:23:07 2022"
, "url":"https://staminachecker.org/get.html"
, "content":" Get STAMINA Need help installing STAMINA? Check out this page. Official Releases Download Latest Release (2.2.5) Other Releases STAMINA/STORM 2.2.1 STAMINA/STORM Version 0.1 alpha (non-optimized) Version 2.0 (Only PRISM Integration) Version 1.1 (Only PRISM Integration) Source Code STAMINA is separated into three repositories: the main STAMINA repository, and two repositories included as submodules: STAMINA/STORM and STAMINA/PRISM. All three are hosted on GitHub. Get Source Code (Main Repository) Repositories Main Repository STAMINA/STORM STAMINA/PRISM Citing Stamina To cite STAMINA in papers, use one of the following citations: To cite STAMINA 2.0, please use the tool paper from VMCAI'22: Roberts R., Neupane T., Buecherl L., Myers C.J., Zhang Z. (2022) STAMINA 2.0: Improving Scalability of Infinite-State Stochastic Model Checking. In: Bernd F., Wies, T. (eds) Verification, Model Checking, and Abstract Interpretation. VMCAI 2022. Lecture Notes in Computer Science, Springer, Cham. Download link: https://link.springer.com/chapter/10.1007/978-3-030-94583-1_16 Copy Citation To cite STAMINA 1.0, please use the tool paper from CAV'19: Neupane T., Myers C.J., Madsen C., Zheng H., Zhang Z. (2019) STAMINA: STochastic Approximate Model-Checker for INfinite-State Analysis. In: Dillig I., Tasiran S. (eds) Computer Aided Verification. CAV 2019. Lecture Notes in Computer Science, vol 11561. Springer, Cham. Download link: https://link.springer.com/chapter/10.1007/978-3-030-25540-4_31 Copy Citation STAMINA 2.5 and STAMINA 3.0 don't yet have papers published about them as they are currently under development. When they do have papers, they will be placed here. "
}
, {
"title":"Documentation - STAMINA Model Checker"
, "date":"Thu Aug 4 13:04:59 2022"
, "url":"https://staminachecker.org/documentation.html"
, "content":" STAMINA Documentation Usage documentation Documentation for the usage of STAMINA can be found at the wiki. This includes STAMINA usage, GUI, algorithm development, and command-line option documentation. Development Documentation For the STORM version, there exists Doxygen documentation. For the PRISM version, there is both Javadoc documentation as well as some markdown files describing each class in the repository. "
}
, {
"title":"Benchmarks - STAMINA Model Checker"
, "date":"Thu Aug 4 11:22:41 2022"
, "url":"https://staminachecker.org/benchmarks.html"
, "content":" Benchmarks In most cases, STAMINA/STORM performed better in general than STAMINA/PRISM, even without the dynamic programming. However, with dynamic programming, many of the runtimes STAMINA/STORM has are substantially better than STAMINA/PRISM. Benchmarking was done on an NZXT computer running Debian 11 (Linux 5.10) with the following properties: Processor: AMD Ryzen ThreadRipper 16-Core 32 Threads RAM: 64 GiB DDR4 Graphics Card: SAPPHIRE You may also expand all or collapse all. STAMINA Runtimes vs. Other Model Checkers STAMINA/STORM 2.5 was compared in runtime to other versions of the STAMINA algorithm, integrated with both PRISM and STORM. Additionally, when the final results for STAMINA compared against itself are finished testing, STAMINA will be compared with other model checkers, such as Modest and Infamy. We cannot directly compare to PRISM or STORM since the models used for testing were unbounded, so both PRISM and STORM would not terminate during the model construction phase. The results below are preliminary results, and don't yet include the Hazard Circuit models, which are the most interesting as they are the largest and often have nested properties. However, even with the existing results, it is evident that STAMINA/STORM 2.5 is substantially faster in general than STAMINA/PRISM or even STAMINA/STORM 2.0. We plan to include full results against all models we will test against in a paper that will be submitted to VMCAI in September. Runtimes Against Other STAMINA Algorithms (in Seconds) Hazard Circuit Jackson Circuit Polling System Robot World Tandem Queue Toggle Switch Toy Model Update Please note that these results are preliminary. Full results are expected to be published in a paper this fall. The word \"fail\" next to a runtime means that particular model checker was unable to produce a bound, either because of an OOM (out of memory) error, or another error. Please select a model class above and click \"update\". STAMINA Probability Results vs. Other Model Checkers STAMINA/STORM was able to consistently and accurately predict probability windows for CSL properties for all tests in the preliminary testing. Again, when full testing is complete (i.e., comparison against other model estimation tools including MODEST and INFAMY), they will be published in a paper, probably sometime in Fall 2022. Hazard Circuit Jackson Circuit Polling System Robot World Tandem Queue Toggle Switch Toy Model Update The values in this table are the probability windows, i.e., PMAX - PMIN. The closer they are to 0.0, the more accurate bound STAMINA was able to produce. An empty value means that this model checker was unable to produce a probability bound. Please select a model class above and click \"update\". STAMINA Number of States Generated vs. Other Model Checkers According to the preliminary results, the state-counts were fairly similar between STAMINA/STORM and STAMINA/PRISM, however, STAMINA/STORM was able to explore more states quicker and with less memory impact than STAMINA/PRISM. Additionally, because STAMINA/STORM builds the transition matrix within its own code (relying on STORM classes to do so), rather than requiring the STORM API to do so, even within STAMINA/STORM, the same number of states can be explored with less work than STAMINA/PRISM. Full results will be published here after testing is complete. "
}
, {
"title":"Wiki Home - STAMINA Wiki"
, "date":"Thu Aug 4 13:41:42 2022"
, "url":"https://staminachecker.org/documentation/wiki/index.html"
, "content":" STAMINA Wiki Welcome to the STAMINA Wiki. Here you will find information about using STAMINA, developing with STAMINA, and STAMINA use cases. Additionally, you will find information about building models, the types of models STAMINA works well for, and information about the hazard circuit systems we used to test it. This wiki is not API documentation. STAMINA does have API docs, which are located here for STAMINA/STORM and here for STAMINA/PRISM. However, those docs are generated using Doxygen, which is a slightly bloated and inefficient system. This wiki is written in vanilla HTML, CSS, and JavaScript, and so it should be faster and more efficient than those. STAMINA/STORM and STAMINA/PRISM are completely different codebases. Despite similar purposes, functionalities, and naming conventions, they are two entirely different pieces of software. STAMINA/STORM integrates with the STORM model checker, and therefore uses it's API to both read models and explore states. STAMINA/PRISM operates likewise on top of the PRISM model checker's API. While we have tried to create a unified frontend for both model checkers, not only do they have different options, there may be slight nuanced differences in how they interpret models and the order in which they explore states. Getting Started You may be interested in one of the following common pages: Building STAMINA/STORM from source Building STAMINA/PRISM from source An introduction to PRISM models "
}
, {
"title":"Installing STAMINA/STORM - STAMINA Wiki"
, "date":"Fri Aug 5 13:34:23 2022"
, "url":"https://staminachecker.org/documentation/wiki/install-sstamina.html"
, "content":" Installing STAMINA/STORM Currently, no version of STAMINA is packaged in any Linux distribution. At some point we will put it in the AUR (Arch User Repository) and the DUR (Debian User Repository). However, the easiest way to get STAMINA/STORM currently is to build it from source. Building from Source Dependencies First, you will need to install all of the dependencies required for STAMINA/STORM. The following dependency lists are supplied for Debian-based machines, Arch-based machines, and MacOS-based machines. (Please note that most of these are also dependencies for STORM, hence why they are required) Debian 11+/Ubuntu 22.04+ (or derivative) sudo apt-get update && sudo apt-get upgrade sudo apt-get install build-essential libboost-all-dev git cmake clang Arch Linux/Manjaro/EndeavorOS sudo pacman -Syuu base-devel git cmake boost-libs clang MacOS 10.12+ brew install cln ginac automake cmake boost glibc clang Manually Installing STORM (Required) STORM must be installed manually for STAMINA to compile. This is so that STAMINA knows where to find the STORM shared objects and link against them. Please follow the guide here to install STORM. Installing STAMINA Once all dependencies (including STORM) have been installed, STAMINA is ready to be installed. You may obtain the source code from the master branch by directly cloning the GitHub repository or you may download a specific release from GitHub as well. git clone https://github.com/fluentverification/stamina-storm stamina-storm Afterwards, you will need to invoke CMake to create a makefile and build STAMINA: cd stamina-storm mkdir build && cd build export STAMINA_HOME=$(pwd) cmake .. -DCMAKE_CXX_COMPILER=$(which clang++) -DSTORM_PATH=$STORM_DIR make -j$(nproc --all) The environment variable STORM_DIR should be set during the STORM install process. If not, it is just the root directory of STORM. Adding STAMINA to your PATH Variable In order to access the sstamina executable from anywhere, you will have to add it to your user's \"path\" variable. The easiest way to do this is to add the following line to your shells resource file (generally .bashrc for Bash, and .zshrc for ZSH): export STAMINA_HOME=path/to/stamina export PATH=$PATH:$STAMINA_HOME/build "
}
, {
"title":"Properties Files - STAMINA Wiki"
, "date":"Fri Aug 5 10:17:50 2022"
, "url":"https://staminachecker.org/documentation/wiki/properties-files.html"
, "content":" Properties Files Properties files are specified in Continuous Stochastic Logic, a format allowing for both state formulas and path formulas. PRISM provides documentation which is both easy to understand, and extensive. It is recommended to reference that page here. The types of properties STAMINA supports Because the STAMINA algorithm estimates state reachability using cumulative path probability, it lends itself well to most types of CSL properties. In most of the testing examples we use, the properties tested were bounded path probability formulas, i.e., \"what is the probability that state formula Φ holds for all states for a path from time 0 s to t s?\" If we reference our example model file from the previous page, an example of a property like this would be as follows: P=? [true U[0,1000] (SpeciesA > 10 & SpeciesB < 30) ] This property asks \"what is probability that from time 0 to 1000 s that all states satisfy SpeciesA > 10 and SpeciesB < 30?\" "
}
, {
"title":"Legacy GUI - Stamina Wiki"
, "date":"Mon Aug 8 16:30:03 2022"
, "url":"https://staminachecker.org/documentation/wiki/gui-legacy.html"
, "content":" This page is unfinished. STAMINA GUI (Legacy) While STAMINA/STORM contains a work-in-progress full GUI that allows you to edit model files and build CSL properties, in order to access both STAMINA/STORM and STAMINA/PRISM from a GUI, we provide a very minimal dialog box that allows you to edit some basic settings and select and run model files. This GUI provides access to both STAMINA/STORM and STAMINA/PRISM, but it is recommended for STAMINA/PRISM as STAMINA/STORM provides a more fleshed-out, fully-featured GUI. Model/Modules file. The file which contains the modules which in their entirety, describe the PRISM model. Properties file: The file with the list of CSL properties to use Undefined constants: PRISM allows you to specify constants at runtime, and therefore STAMINA/JAVA does as well The file to export the output of STAMINA to. The choice of whether to use STAMINA/STORM or STAMINA/PRISM The output window where STAMINA will dump log and results. Opens the \"More Options\" window Analyzes the model Reduction factor (κ) Kappa reduction factor (rκ) Approximation factor Required maximal probability window for STAMINA to terminate The maximum number of refinement iterations Will there be property refinement? Export the modified model file with the Absorbing module (generally used for debugging and proof) Export the modified CSL properties (generally used for debugging and proof) Use rank transitions. Method to use Method to use Method to use Method to use Method to use Set defaults Finish (checks validity of options) "
}
, {
"title":"XStamina GUI - Stamina Wiki"
, "date":"Mon Aug 8 16:30:03 2022"
, "url":"https://staminachecker.org/documentation/wiki/gui-new.html"
, "content":" XSTAMINA GUI (STAMINA/STORM Only) The XStamina GUI requires a few more dependencies as opposed to the CLI version of STAMINA/STORM. In addition to the dependencies required for STAMINA/STORM, the following packages are required for XStamina: sudo apt install libqt5-dev libkf5xmlgui-dev libkf5textwidgets-dev libkf5kio-dev libkf5texteditor-dev qtbase5-dev qtdeclarative5-dev libqt5svg5-dev libkf5i18n-dev libkf5coreaddons-dev extra-cmake-modules For Arch/Manjaro distributions: sudo pacman -S kde-sdk-meta (Click to expand) Toolbar and menubar Model information tree (only shows information if the model is built) Model editing window Quick model information Tab-bar: gives acces to the model editor, properties editor, results viewer and log window. Using xSTAMINA Editing Model files, in the PRISM language, are edited in the Model Editor tab. An autocomplete is provided which contains PRISM keywords, module and variable names, constants, and other useful model information. This autocomplete is updated when the model is parsed (i.e., the model tree is rebuilt). This can only happen when the model has no syntax errors. Property files are similarly edited in the Properties Editor tab. Both editors provide the following syntax highlighting scheme (colors are editable): Keywords: any keyword in the PRISM language, by default highlighted in a deep blue. The following keywords are highligted and therefore cannot be used as identifiers: A, clock, const, ctmc, C, double, dtmc, E, endinit, endinvariant, endmodule, endobservables, endrewards, endsystem, false, formula, filter, func, F, global, G, init, invariant, I, label, max, mdp, min, module, X, nondeterministic, observable, observables, of, Pmax, Pmin, P, pomdp, popta, probabilistic, prob, pta, rate, rewards, Rmax, Rmin, R, S, stochastic, system, true, U, W (see https://www.prismmodelchecker.org/manual/ThePRISMLanguage/ModulesAndVariables) Comments: Single-line comments, which start with //, or multi-line comments, which begin with /* and end with */. Generally a muted grey. Numerics: PRISM by default does not allow floating point variables (only natural numbers), but does allow floating point values in constant expressions. Both will highlight in red by default. Datatypes: Any datatype supported by PRISM, specifically int, double, or bool. Additionally, formula, invariant, and label are also highlighted by this. Functions: Anything which looks like an invocation of a function, namely ending with (.*). Strings: PRISM only supports double-quote separated strings, so \"foo\" is valid, but 'foo' is not. Constants: Constants may be defined by any identifier, but by convention, they are in all caps, so xSTAMINA highlights anything in UPPER_SNAKE_CASE as a constant. By default, the editor uses tabs, and has a tab width of 4 characters. This, the typeface of the main editor, and the colors used in syntax highlighting can be edited in the General tab of the Edit → Preferences dialog, shown below. Colors and font size and typeface are stored in a preferences file xSTAMINA Color Scheme Editor xSTAMINA Color Scheme Editor Both the model and properties file can be edited using a find and replace editor, accessible via Ctl+F or Ctl+R for find and replace respectively. Text find, accessible by Ctl+F Find and replace, accessible by Ctl+R Text size can be changed via Ctl++ and Ctl+-. Model Checking Parameters such as κ, rκ, and w can be found in the preferences window. These are not saved in a configuration file and can be changed before each model checking. All properties in the property file can be checked via Ctl+Shift+Return, or the Build Model and Check Properties button on the Model Editor tab. Known Bugs xSTAMINA has some known bugs not present in the CLI version. First and foremost, it behaves strangely with multiple properties in the same file. This is something we are working to fix, but have not yet found the source of. "
}
, {
"title":"Options - STAMINA Wiki"
, "date":"Thu Aug 4 13:42:30 2022"
, "url":"https://staminachecker.org/documentation/wiki/options.html"
, "content":" Options The following options are user-specifiable and will affect how the STAMINA algorithm runs. You will learn how to set these via the CLI options in the next page. Reachability Threshold (κ) The reachability threshold is passed into STAMINA via the kappa command line argument. Definition: The threshold probability that a particular state must be at to be considered “reachable”. Since we are in a Continuous Time Markov Chain, transitions are represented by a “rate” rather than a flat probability, meaning that a rate of 0.0 is undefined for a state transition. However, the number of states that the “reduced” state space model can reach is determined by this threshold. In the reachability analysis method of the StaminaModelBuilder classes (STAMINA/STORM) or the InfCTMCModelGenerator() class (STAMINA/PRISM), a truncated state space is created, based on this reachability threshold. STAMINA only includes states where the probability mass is clustered, starting breadth-first from the initial state. This means that states less likely to be chosen and included in the truncated model if: They are farther away from the initial state. There is a low transition rate to that state. WARNING: The probability threshold is the probabilistic state search termination value; i.e., the lower the reachability threshold, the more states are to be explored, and the longer the simulation could take. If the probability threshold is set too low, then very little state space truncation could occur, causing the system to run out of resources. Do not set the value of the reachability threshold to 0, as this will result in an infinite (and therefore uncomputable) state space. Kappa (κ) reduction factor (rκ) Definition: the kappa reduction factor is the reduction factor on the reachability threshold, kappa (see above). It defines how much the reachability threshold is reduced by: κmin = κ / rκ. As mentioned above, too low of a reachability threshold could cause overuse of system resources, meaning that the kappa reduction factor ought not to be excessively high. The κ reduction factor is used to compute the lower bound probability Pmin, the lower bound of the probability that Φ, the state formula, being satisfied within the state space. Misprediction Factor (m) Definition: This is used in determining the termination of the exploration. If Π is the probability we are in a terminal state, then exploration is terminated when Π < w / m. Additionally, if the bound between Pmax and Pmin is greater than the window, the misprediction factor will be updated accordingly. This updating is done in StaminaModelBuilder::buildMatrices() (STAMINA/STORM) or InfCTMCModelGenerator.doReachabilityAnalysis() (STAMINA/PRISM). Max Approximate Count Definition: The maximum number of approximation iterations (the second-outermost while loop in the algorithm). Max Refinement Count Definition: The maximum number of refinement iterations used in computing the upper and lower bounds of the probabilities of reaching a certain state, Pmax and Pmin. Probability Error Window (w) Definition: The defined maximum difference between Pmax and Pmin. This is user specified, and affects the computation of the misprediction factor, m. No Property Refining Definition: Whether or not to use property based refinement. Rank Transitions Definition: a boolean representing whether or not rank transitions will be used. CUDD Memory Limit Definition: A string representing the memory limit available to STAMINA and the associated PRISM model we are building. WARNING Problems could arise if there are more states needed to be built than memory available, so make sure that the reachability threshold and its reduction factor are reflective of your memory limits. STAMINA will terminate if a memory limit is hit, regardless of whether or not the probability window is found tight enough. Export Model Definition: a boolean representing whether or not we are going to export the model. Export Filename Definition: If we are going to export the model, to what filename will we export it? Export Perimeter States Definition: A boolean representing whether or not we are going to export the perimeter states to file. Export Perimeter Filename Definition: if we are going to export the perimeter states to a file, what shall be the filename? Import Model Definition: a boolean representing whether or not we are going to import a model file from PRISM. Acceptable file extensions are .pm, .prism, and others associated with the PRISM modelling system. However, this tool does not check the file extension, or its contents before trying to import, so importing an incompatible file will raise a PrismException. Associated methods: Import Filename Definition: The name of the file whose models STAMINA is going to import. Specific Property Definition: Whether or not this is associated with a specific property. Property Name Definition: The name of the specific property associated with these options. Export Transitions to File Definition: The filename where the export transitions will be sent. "
}
, {
"title":"Installing STAMINA/PRISM - STAMINA Wiki"
, "date":"Thu Aug 4 13:42:09 2022"
, "url":"https://staminachecker.org/documentation/wiki/install-pstamina.html"
, "content":" Installing STAMINA/PRISM STAMINA/PRISM is written in Java and depends on the PRISM Model Checker. Multiple methods of auto-installing STAMINA/STORM have been created. Unfortunately, we have not yet migrated STAMINA/PRISM to gradle, like we have with the imsam package. Regardless of the method you use, you will need to install the dependencies first. The following command will install them on Debian 11+/Ubuntu 22+: sudo apt-get update && sudo apt-get -y install openjdk-11-jre openjdk-11-jdk git build-essential Method 1: The Shell Script (Recommended) Simply clone the GitHub repository and run the provided install script: git clone https://github.com/fluentverification/stamina-prism stamina-prism cd stamina-prism chmod +x install.sh && install.sh Method 2: The Perl Script (Legacy) The Perl script clones both STAMINA and PRISM, so it should be directly passed into the Perl executable from curl or wget. Using curl: perl -e \"$(curl https://raw.githubusercontent.com/fluentverification/stamina/master/install.pl)\" Using wget: wget https://raw.githubusercontent.com/fluentverification/stamina/master/install.pl && perl install.pl && rm install.pl Method 3: Installing Manually First, you will need to install PRISM. STAMINA requires the installed version of PRISM to be version 4.5. git clone https://github.com/prismmodelchecker/prism prism cd prism/prism git checkout v4.5 make -j$(nproc --all) make install export PRISM_HOME=$(pwd) After you have installed PRISM, you are ready to install STAMINA: git clone https://github.com/fluentverification/stamina stamina-prism cd stamina-prism/stamina make PRISM_HOME=$PRISM_HOME Finally, you must create a .staminarc file in your home directory so STAMINA knows where to find classes: touch ~/.staminarc echo \"export_JAVA_OPTIONS=-Xmx12288m\" >> ~/.staminarc echo \"export PRISM_HOME=$PRISM_HOME\" >> ~/.staminarc echo \"export STAMINA_HOME=$(pwd)/stamina\" >> ~/.staminarc "
}
, {
"title":"Command-Line Arguments - STAMINA Wiki"
, "date":"Fri Aug 5 13:35:06 2022"
, "url":"https://staminachecker.org/documentation/wiki/cli-args.html"
, "content":" Command-Line Arguments Now that you know how to create PRISM model files and CSL properties files, you are ready to use STAMINA. STAMINA comes in two executables, sstamina for STAMINA/STORM and pstamina for STAMINA/PRISM. We also have a simple Python script simply called stamina, which takes --storm and --prism args and passes all remaining args to either sstamina or pstamina. For both versions, the first two (non-named) command-line parameters are the model file path and properties file path respectively. These are required to be in .sm, .prism and .csl format respectively. The basic syntax of invoking STAMINA via the command-line is as follows: stamina --storm $MODEL_FILE $PROPERTIES_FILE [OPTIONS] The --storm and --prism options allow you to specify which model checker to use. STAMINA/STORM and STAMINA/PRISM have different sets of options (although there is some overlap), in order to work with their respective model checkers. The stamina executable simply passes the options you give into either STAMINA/STORM or STAMINA/PRISM, so make sure to choose the correct options. Though there are many parallels to the CLI options for STAMINA/STORM and STAMINA/PRISM, there are some differences. These are the available options for each respective version: STAMINA/STORM Usage and Options The following options are available for STAMINA/STORM Usage: sstamina [OPTION...] MODEL_FILE PROPERTIES_FILE STAMINA -- truncates infinite CTMC state space and passes into STORM -c, --const=\"C1=VAL,C2=VAL,C3=VAL\" Comma separated values for constants -C, --cuddMaxMem=memory Maximum CUDD memory, in the same format as PRISM (default: 1g) -e, --export=filename Export model to a (text) file -f, --approxFactor=double Factor to estimate how far off our reachability predictions will be (default: 2.0) -i, --import=filename Import model to a (text) file -I, --iterative Use the STAMINA 2.5 method (iterative) -J, --reExploring Use the STAMINA 2.0 method (the method in STAMINA/PRISM) -k, --kappa=double Reachability threshold for the first iteration (default: 1.0) -M, --maxIterations=int Maximum iteration for solution (default: 10000) -n, --maxApproxCount=int Maximum number of iterations in the approximation (default 10) -p, --property=propname Specify a certain property to check in a model file that contains many -P, --priority Use the STAMINA 3.0 method (priority) -r, --reduceKappa=double Reduction factor for Reachability Threshold (kappa) during the refinement step (default 2.0) -R, --noPropRefine Do not use property based refinement. If given, the model exploration method will reduce kappa and do property independent definement (default: off) -S, --exportPerimeterStates=filename Export perimeter states to a file. Please provide a filename. This will append to the file if it is existing -t, --exportTrans=filename Export the list of transitions and actions to a specified file name, or to trans.txt if no file name is specified. Transitions are exported in the format <Source State Index> <Destination State Index> <Action Label> -T, --rankTransitions Rank transitions before expanding (default: false) -V, --maxStates=integer The maximum number of states to explore in an iteration (default 2000000) -w, --probWin=double Probability window between lower and upperbound for termination (default: 1.0e-3) -?, --help Give this help list --usage Give a short usage message Mandatory or optional arguments to long options are also mandatory or optional for any corresponding short options. STAMINA/PRISM Usage and Options The following options are available for STAMINA/PRISM Usage: stamina [options] <model-file> <properties-file> <model-file> .................... Prism model file. Extensions: .prism, .sm <properties-file> ............... Property file. Extensions: .csl Options: ======== -kappa <k>.......................... ReachabilityThreshold for first iteration [default: 1.0] -reducekappa <f>.................... Reduction factor for ReachabilityThreshold(kappa) for refinement step. [default: 1.25] -approxFactor <f>................... Factor to estimate how far off our reachability predictions will be [default: 2.0] -pbwin <e>.......................... Probability window between lower and upperbound for termination. [default: 1.0e-3] -maxapproxcount <n>................. Maximum number of approximation iteration. [default: 10] -noproprefine ...................... Do not use property based refinement. If given, model exploration method will reduce the kappa and do the property independent refinement. [default: off] -cuddmaxmem <memory>................ Maximum cudd memory. Expects the same format as prism [default: 1g] -export <filename>.................. Export model to a file. Please provide a filename without an extension -exportPerimeterStates <filename>... Export perimeter states to a file. Please provide a filename. This will append to the file if it is existing -import <filename>.................. Import model to a file. Please provide a filename without an extension -property <property>................ Specify a specific property to check in a model file that contains many -const <vals> ...................... Comma separated values for constants -exportTrans <filename>............. Export the list of transitions and actions to a specified file name, or to trans.txt if no file name is specified. Transitions exported in the format srcStateIndex destStateIndex actionLabel Examples: -const a=1,b=5.6,c=true Other Options: ======== -rankTransitions ................... Rank transitions before expanding. [default: false] -maxiters <n> ...................... Maximum iteration for solution. [default: 10000] -power ............................. Power method -jacobi ............................ Jacobi method -gaussseidel ....................... Gauss-Seidel method STAMINA Information FLUENT Information Papers and Research STAMINA/STORM State-space truncation (STAMINA) Google Scholar STAMINA/PRISM Property-Directed Reachability Contact Developers Counterexample Generation Fluent Website Contact Fluent STAMINA is developed at Utah State University and is part of the tools developed by the FLUENT Team. The STAMINA tool is licensed under the GPLv3 license, and the model checkers it integrates with, STORM and PRISM, are under the GPL 3.0 and 2.0 licenses respectively. This website is designed and developed by hand by Josh Jeppson. The content and design of this website is licensed under the <a href=https://creativecommons.org/licenses/by-nc-sa/3.0/>CC-BY-SA-NC license</a>. This website uses the Breeze Icons from KDE licensed under the GPL3. "
}
, {
"title":"Model Files - STAMINA Wiki"
, "date":"Tue Aug 9 09:12:36 2022"
, "url":"https://staminachecker.org/documentation/wiki/model-files.html"
, "content":" Model Files Model files are specifications for state-spaces based on real-life interactions between elements within a system. Model files may implicitly create state spaces, such as PRISM files and JANI files, or explicitly instantiate every state with values, such as in transition files. These model formats may be bounded or unbounded and may be deterministic or nondeterministic. They may be in one of the following model types: CTMC: Continuous-time Markov Chains DTMC: Discrete-time Markov Chains MDP: Markov Decision Processes MA: Markov Automaton And more... STAMINA/STORM supports both CTMC and DTMC models, and STAMINA/PRISM only supports CTMCs. Both versions of STAMINA support bounded and unbounded models, as well as only deterministic models. Nondeterministic models will throw an error. PRISM Models PRISM models are a type of model format designed for the PRISM model checker . They allow for many types of models to be specified, and are composed of modules and variables. PRISM has documentation for the entire language specification, located here . Because full documentation for the PRISM language exists on their website, STAMINA will only provide a brief overview of the syntax. All PRISM models must first contain a line which says what type of model they are. For STAMINA, that line is most likely to be ctmc. From there, globally-accessible variables and modules may be declared from the supported types. Modules are a way of encapsulating certain elements of a model. Generally a module contains a variable, and all of the reactions that can affect that variable. Reactions are in the format: [action] guard -> prob1 : (var1'=var1+value1) + prob2 : (var1'=var1+value2) The expression immediately following the probability is the update expression, specifying the new value for var1 using the var1' syntax. As an example of a simple PRISM model, let us create a simple two-species network, with one unbounded variable, and one bounded variable: ctmc // We define our variables and their reactions in a module module SpeciesA_Def // This variable is \"bounded\" SpeciesA : [0..100] init 0; // We cannot decrement in species A if the value is 0 // This basically says \"if SpeciesA is equal to 0, you may choose from two transitions: // 1. Increment by 1 with transition rate 5, or, // 2. Increment by 5 with transition rate 1. [] (SpeciesA = 0) -> 5 : (SpeciesA'=SpeciesA+1) + 1 : (SpeciesA'=SpeciesA+5); // However, if there is a nonzero amount of SpeciesA, we have one more transition: we can decrement by 1 with transition rate 2. [] (SpeciesA > 0) -> 5 : (SpeciesA'=SpeciesA+1) + 1 : (SpeciesA'=SpeciesA+5) + 2 : (SpeciesA'=SpeciesA-1); endmodule module SpeciesB_Def // This variable is \"unbounded\" SpeciesB : int init 0; // This species has only one increment and one decrement [] (SpeciesB = 0) -> 1 : (SpeciesB'=SpeciesB+1); // Again, if there is a nonzero amount of this species, there can be a decrement. [] (SpeciesB > 0) -> 1 : (SpeciesB'=SpeciesB+1) + 0.5 : (SpeciesB'=SpeciesB-1) endmodule Note: as soon as any variable in a model file is unbounded (i.e., any numerical data type), the model becomes unbounded. STAMINA was created specifically to deal with unbounded models, but if you try to check an unbounded model with pure PRISM or STORM, they will either throw an error or run indefinitely. This model will create an infinite-state CTMC with deterministic choices for probabilistic transitions. This would be a prime example of a model that would be perfect for STAMINA. JANI Model Files JANI is a JSON-based model-specification language designed to be easily parsable and versatile. STAMINA/PRISM currently does not support JANI, but STAMINA/STORM is slated to use STORM's JANI-parser to add support in the next major release. JANI provides a complete language specification which is easy to read and understand. We recommend you view that here . Currently, no version of STAMINA supports JANI, but STAMINA/STORM will support it (by making use of STORM's already-built JANI parser) in STAMINA v3.0. If you need to check a JANI model, it is recommended to bound all variables and check in pure STORM, or use STORM's JANI-to-PRISM converter before sending the model to STAMINA. "
}
, {
"title":"The STAMINA Algorithm(s) - STAMINA Wiki"
, "date":"Mon Aug 8 15:54:51 2022"
, "url":"https://staminachecker.org/documentation/wiki/algorithm.html"
, "content":" The STAMINA Algorithm(s) STAMINA contains multiple algorithms to perform state-space truncation. This page will provide an overview of them The STAMINA 1.0 Algorithm STAMINA 1.0 was originally developed by several students under Dr Zhen Zhang, including Thakur Neupane. The basic idea of the algorithm is that for each iteration of κ, states are only explored if an estimated reachability value (based somewhat on the embedded DTMC). While the probability estimate window is too wide, κ is progressively reduced and state exploration is continued. The problem with this was that as κ was reduced, we had no way to continue exploring states we had already truncated in previous iterations. The STAMINA 2.0/2.1 Algorithm STAMINA 2.0 is the naïve approach to fixing the problem presented in STAMINA 1.0: simply re-explore the entire state space with the current value of κ. The logic regarding performance is that model checking with PRISM was the bottleneck in the algorithm, whereas the state exploration was extremely fast, likely because the PRISM model checker spent far more time checking rather than building the model. However, when this was implemented in C++ to interface with the STORM model checker, precisely the opposite was found: that the model building and truncating were the bottleneck. However, the entirety of STAMINA 2.0 was far from naïve. STAMINA 2.0 introduced a new means of keeping track of state reachability, solving another problem in STAMINA 1.0: when a state had been explored, its reachability probability was zeroed out, allowing state re-exploration, and multiple paths to a state to contribute to a state's estimated reachability. This novelty earned it a spot in VMCAI'22. Dynamic Programming Improvements (STAMINA 2.5) In order to make STAMINA/STORM faster, in addition to memory pooling and decreased use of std::unordered_map and std::unordered_set (which after much testing, were determined to be far slower than the Java equivalent), certain dynamic programming improvements were devised to the STAMINA 2.0 algorithm. Please note that these are implemented exclusively in the STORM integration. The improvements simply keep track of the reachability that would have been lost in previous iterations and enqueue \"lost\" states to be explored alongside terminal states of the last iteration, rather than either the initial state (STAMINA 2.0) or the previous terminal states (STAMINA 1.0). STAMINA's Multithreading Protocol Another major novel improvement slated to be released with STAMINA 2.5 is the use of multi-threading, and a custom protocol for the control thread to grant access without having to store mutual-exclusions for every state (extremely memory intensive), or having to lock all or part of the state space every time a thread requests control of a state (reduces the improvement of multithreading). This new protocol is among the improvements we are looking to include in a paper this fall. The STAMINA multithreading protocol is based on two main ideas: first, that threads can \"own\" states and only explore states that they own, and second, that ownership of states can expire after a certain amount of time. Threads can ask who owns a state without locking the mutex on the datastructure keeping track of that, but they must lock that mutex in order to request ownership of the state. A single control thread mantains the governing data structure, and state ownership expires based on a LRU (least-recently used) policy. STAMINA's multithreading protocol has not yet been functionally implemented in STAMINA yet. That is slated to be released next month. The STAMINA 3.0 Algorithm STAMINA 3.0 (not yet released) reduces complexity of the algorithm further. Rather than using κ and rκ to conditionally truncate states, all states, as they are explored, are inserted into a priority queue on the value π[s], the estimated reachability of that state. States are explored in order of their estimated reachability. If a current state transitions into a state that is already enqueued, we do not force the queue to re-order until that state is dequeued and explored. The STAMINA Heuristic Algorithm The STAMINA Heuristic algorithm has not yet been implemented nor tested but would provide an alternate means of termination rather than estimated terminal reachability. "
}
, {
"title":"QEST'23 Submission Results - STAMINA Model Checker"
, "date":"Mon May 22 16:01:24 2023"
, "url":"https://staminachecker.org/results/qest23.html"
, "content":"  QEST 2023 STAMINA Full Results On this page, you will find a full listing of the results. Results are also downloadable in csv and OOXML Spreadsheet (XLSX) format. Results are delineated by Runtime, Pmin/Pmax and number of states generated.    Note, a summary in the differences we found between PRISM and STORM, without STAMINA involved, can be found here  Runtime Download CSV    Probabilities (PMin and Pmax) Download CSV    State Count Download CSV     "
}
, {
"title":"Storm and PRISM differences QEST'23 results - STAMINA Model Checker"
, "date":"Mon May 22 16:01:24 2023"
, "url":"https://staminachecker.org/results/qest23/storm-prism-difference.html"
, "content":"STORM vs PRISM Probability Difference The following table quantifies the difference (albeit small one) between Storm and Prism on some small tests. The Jackson models did not finish for either model checker, and ended with OOM errors."
}
]
}
